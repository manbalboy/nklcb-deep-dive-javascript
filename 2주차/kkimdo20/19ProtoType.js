// 자바스크립트는 클래스 기반 객체지향 프로그밍 언어보다 효율적이며, 더 강력한 객체 지향 프로그래밍 능력을 지니고 있는
// 프로토타입 기반의 객체지향 프로그래밍 언어다.

// ES6에서 클래스가 도입되었다 하지만, ES6의 클래스가 기존의 프로토타입 기반 객체지향 모델을 폐지하고
// 새로운 객체지향 모델을 제공하는 것은 아니다. 사실 클래스도 함수이며, 기존 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지 않는다.
// 클래스는 생성자 함수보다 엄격하며 클래스는 생성자 함수에서는 제공하지 안흔ㄴ 기능도 제공한다.
// 따라서 클래스를 프로토타입 기반 객체 생성패턴의 단순한 문법적 설탕으로 보기보다는 새로운 객체 생성 메커니즘으로 보는 것이 좀 더 합당하다.

// 자바스크립트를 이루고 있는 거의 "모든 것"이 객체다.

// 객체 지향 프로그래밍은 실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작한다.
// 실체는 "속성"을 갖고 있고, 이를 통해 실체를 인식하거나 구별할 수 있다.
// 사람에게는 다양한 속성이 있으나 우리가 구현하려는 프로그램에서는 사람의 "이름"과 "주소"라는 속성에만 관심이 있을 때,
// 다양한 속성중에 프로그램에 필요한 속성만 간추려 내어 표현하는 것을 "추상화"라고 한다.

// 이처럼 속성을 통해 여러개의 값을 하나의 단위로 구성한 복합적인 자료구조를 "객체"라고 한다.

// 원에는 반지름이라는 속성이 있다. 이 반지름을 갖고, 원의 지름,둘레,넓이를 구할 수 있다. 이때 반지름은 원의 "상태를 나타내는 데이터".
// 원의 지름, 둘레, 넓이를 구하는 것은 동작이다.
// "따라서 객체의 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조"

// 잘 이해한 것인지는 모르겠지만, 자바의 "전역 스코프 = 필드" "생성자 = 생성자 프로퍼티" "메소드 = 메소드" 정도로 이해가 된다.

// 상속은 객체지향 프로그램의 핵심 개념, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속 받아 그대로 사용할 수 있는 것. (자바 extends)
// 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.

function Circle(radius){ // 생성자 함수
    this.radius = radius; 
}

Circle.prototype.getArea = function () { // Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를
    return Math.PI * this.radius ** 2;  // 공유해서 사용할 수 있도록 프로토타입에 추가한다. 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩 되어있다.
}                           

// 인스턴스 생성
const circle1 = new Circle(1);
const Circle2 = new Circle(2);

// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는
// 프로토타입 Circle.prototype으로부터 getArea 메서드를 상속받는다.
// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유한다.

console.log(circle1.getArea === Circle2.getArea); // true

// 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며 이 내부 슬롯의 값은 프로토타입의 참조다.

// 모든 객체는 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.

// __proto__ 접근자 프로퍼티는 상속을 통해 사용된다. 객체가 직접 소유하는 프로퍼티가 아니라, Object.prototype의 프로퍼티다.
// 모든 객체는 상속을 통해 Object.prototype.__proto__ 접근자 프로퍼티를 사용할 수 있다.

// Object.prototype
// 모든 객체는 프로토타입의 계층 구조인 프로토타입 체인에 묶여 있다. 자바스크립트 엔진은 객체의 프로퍼티에
// 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 __proto__ 접근자 프로퍼티가 가리키는 참조를 따라 자신의 부모 역할을
// 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 프로토타입 체인의 종점, 즉 프로토타입 체인의 최상위 객체는 Object.prototype이며
// 이 객체의 프로퍼티와 메서드는 모든 객체에 상속된다.

// [[Prototype]] 내부 슬롯의 값, 프로토타입에 접근하기 위해 __proto__ 접근자 프로퍼티를 사용하는 이유는
// 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서다.

// __proto__ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.
// 모든 객체가 해당 접근자 프로퍼티를 사용하는 것은 아니기 때문이다.
// 직접 상속을 통해 Object.prototype을 상속받지 않는 객체를 생성할 수 도 있기 때문이다.

// Object.getPrototypeof 메서드와 Object.setPrototypeof 메서드는 get.Object.prototype.__proto__와 set.Object.prototype.__proto__의 처리 내용과 정확히 일치한다.


// 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.
(function (){}).hasOwnProperty('prototype');  // true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty('prototype'); // false

// 모든 객체가 가지고 있는(엄밀히 말하면 Object.prototype으로부터 상속받은) __proto__ 접근자 프로퍼티와 함수 객체만이 갖고 있는
// prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다.

function Person(name){
    this.name = name;
}
const me = new Person('Lee'); // 결국 Person.prototype과 me.__proto__는 결국 동일한 프로토타입을 가리킨다.
console.log(Person.prototype === me.__proto__); // true

function Person(name){ // 생성자 함수
    this.name = name;
}
const me = new Person('Lee'); // me 객체의 생성자 함수는 Person이다.
console.log(me.constructor === Person); // true

// 추상 연산은 ECMAScript 사양에서 내부 동작과 구현 알고리즘을 표현한 것. 설명을 위해 사용되는 함수와 유사한 의사코드

function foo() {} // foo 함수는 Function 생성자 함수로 생성한 함수 객체가 아니라 함수 선언문으로 생성.

console.log(foo.constructor === Function); // true 하지만 constructor 프로퍼티를 통해 확인해보면 함수 foo의 생성자 함수는 Function 생성자 함수다.

// 프로토타입과 생성자 함수는 단독으로 존재할 수 없다. 언제나 쌍으로 존재한다.

// 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입은 다음과 같다.

// 객체 리터럴 : Object(생성자 함수) Object.prototype(프로토타입)
// 함수 리터럴 : Function(생성자 함수) Function.prototype(프로토타입)
// 배열 리터럴 : Array(생성자 함수) Array.prototype(프로토타입)
// 정규 표현식 리터럴 : RegExp(생성자 함수) RegExp.prototype(프로토타입)

// 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.
// 생성자 함수로서 호출할 수 있는 함수, constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.

console.log(Person.prototype); // {constructor : function} 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.

function Person(name){ // 생성자 함수
    this.name = name;
}

// non-constructor는 프로토타입이 생성되지 않는다.
const Person = name =>{
    this.name = name;
};
console.log(Person.prototype) //undefined

// 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체다. Math, Reflect,JSON을 제외한 표준 빌트인 객체는 모두 생성자 함수.

// 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재한다.
// 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당된다.

// 객체는 다음과 같이 다양한 생성 방법이 있다.
// - 객체 리터럴
// - Object 생성자 함수
// - 생성자 함수
// - Object.create 메서드
// - 클래스(ES6)

// 세부적인 객체 생성 방식의 차이는 있으나 
// 추상연산 OrdinaryObjectCreate에 의해 생성된다는 공통점이 있다.

// 프로토타입은 위의 추상연산에 전달되는 인수에 의해 결정된다.
// 이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.

// Object.prototype을 프로토타입 체인의 종점이라 한다.
// 프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘이라고 할 수 있다.
// 스코프 체인은 식별자 검색을 위한 메커니즘 이라고 할 수 있다.
// 스코프 체인과 프로토타입 체인은 서로 연관없이 별도로 동작하는 것이 아니라
// 서로 협력하여 식별자와 프로퍼티를 검색하는 데 사용된다.

me.hasOwnProperty('name');

// 오버라이딩 : 상위 클래스가 갖고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식
// 오버로딩 : 함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해
// 메서드를 구별하여 호출하는 방식이다. 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현할 수 있다.

// instanceof 연산자는 좌변에 객체를 가리키는 식별자 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다.
// 만약 우변의 피연산자가 함수가 아닌경우 타입에러가 발생한다.

// 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true로 평가되고, 그렇지 않은 경우에는 false로 평가된다.
// 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아니라
// 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인한다.

// for.. in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트[[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거 한다.

const person = {
    name : 'Lee',
    address : 'Seoul',
    __proto__:{ age : 20}
};

for (const key in person){
    console.log(key + ':' + person[key]);

}

// for... in 문은 키가 심벌인 프로퍼티는 열거하지 않는다.

// 결론
// 자바스크립트는 명령형, 함수형, 프로토타입 기반, 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어.
// 자바스크립트를 이루고 있는 거의 "모든 것"이 객체다(오해하지말자)

// 실체는 특징이나 성질을 나타내는 "속성"을 갖고 있고 이를 통해 인식하거나 구별할 수 있다.
// 다양한 속성 중에서 필요한 속성만 간추려 내어 표현하는 것을 "추상화"라고 한다.
// 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조를 "객체"라고 한다.
// "따라서 객체의 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조"

// 잘 이해한 것인지는 모르겠지만, 

// "전역 스코프 = 필드" 
// "값 = "데이터 프로퍼티"
// "생성자 = 생성자 프로퍼티" 
// "메소드 = 메소드(동작)" 정도로 이해가 된다

// 자바스크립트는 prototype을 기반으로 상속을 구현한다.(어려웠다.)
// 모든 객체는 하나의 프로토타입을 갖고, 생성자 함수와 연결되어 있다.
// 그렇기 때문에 __prototype__ 접근자 프로퍼티를 통해 자신의 프로토타입 내부 슬롯에 간접 접근할 수 있다.
// 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.(일반 객체는 prototype 프로퍼티를 소유하지 않음)
// 하지만 모든 객체가 Object.prototype으로 부터 상속받은 __proto__ 접근자 프로퍼티와
// 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토 타입을 가리킨다.
// 코드내에서 __proto__ 접근자 프로퍼티를 직접 사용하는 것은 권장하지 않는다.

// 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다.
// 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성되기 때문.
// 생성자 함수로서 호출할 수 있는 함수는 함수 정의가 평가되어 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
// 자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면
// [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순착적으로 검색한다.
// Object.prototype은 프로토타입 체인의 종점이다. 프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘.
// 스코프 체인은 식별자 검색을 위한 메커니즘이다.(식별자 = 변수,함수,속성,메소드)

// 두 체인은 서로 연관없이 별도로 동작하는 것이 아닌 협력하여 검색하는데 사용된다.

// 자바스크립트는 오버라이딩을 할 수 있다.(상위클래스 메서드를 하위 클래스가 재정의함.)
// 오버로딩 또한 arguments를 사용하여 구현할 수는 있다. (지원은 안한다.)
// 프로토타입은 임의의 다른 객체로 변경할 수 있다.

// 객체 instanceof 생성자 함수 : 연산자를 사용하는 방식
// 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true로 평가됨.
// instanceof 연산자는 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인한다.

// for ... in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로퍼티 중에서 [[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거한다.

